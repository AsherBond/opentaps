/*
 * Copyright (c) 2010 - 2011 Open Source Strategies, Inc.
 *
 * Opentaps is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Opentaps is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Opentaps.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.opensourcestrategies.activities.reports;

import java.awt.Color;
import java.io.IOException;
import java.sql.Timestamp;
import java.text.NumberFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.TreeSet;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.labels.StandardPieSectionLabelGenerator;
import org.jfree.chart.plot.PiePlot;
import org.jfree.chart.servlet.ServletUtilities;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.ui.RectangleInsets;
import org.ofbiz.base.util.Debug;
import org.ofbiz.entity.GenericEntityException;
import org.ofbiz.entity.GenericValue;
import org.ofbiz.entity.condition.EntityCondition;
import org.ofbiz.entity.condition.EntityOperator;
import org.ofbiz.service.LocalDispatcher;
import org.opentaps.base.constants.OpentapsConfigurationTypeConstants;
import org.opentaps.base.constants.RoleTypeConstants;
import org.opentaps.base.entities.ActivityFact;
import org.opentaps.base.entities.PartyRole;
import org.opentaps.common.reporting.etl.UtilEtl;
import org.opentaps.common.util.UtilMessage;
import org.opentaps.domain.DomainsLoader;
import org.opentaps.domain.party.PartyRepositoryInterface;
import org.opentaps.foundation.entity.Entity;
import org.opentaps.foundation.infrastructure.Infrastructure;
import org.opentaps.foundation.infrastructure.InfrastructureException;
import org.opentaps.foundation.infrastructure.User;
import org.opentaps.foundation.repository.RepositoryException;
import org.opentaps.foundation.service.Service;

/**
 * Charts for Financials generated by the JFree API.
 */
public class JFreeActivitiesCharts extends Service {

    private static String MODULE = JFreeActivitiesCharts.class.getName();

    /** Width of the generated charts. */
    public static final int CHART_WIDTH = 400;
    /** Height of the generated charts. */
    public static final int CHART_HEIGHT = 300;

    /**
     * Snapshot chart that shows the breakdown of leads according to their last activity, in Old / Recent / No activity categories.
     * @param cutoffDays Number of days that cuts off from today date and make it reading point for old and recent activties.
     * @param locale a <code>Locale</code> value
     * @param dispatcher a <code>LocalDispatcher</code> value
     * @param user a <code>GenericValue</code> value
     * @param timeZone a <code>TimeZone</code> value
     * @return file name of the chart PNG
     * @exception Exception if an error occurs
     */
    public static String createActivitiesByLeadSnapshotChart(int cutoffDays, Locale locale, LocalDispatcher dispatcher, GenericValue user, TimeZone timeZone) throws Exception {
        return createActivitiesByLeadSnapshotChart(cutoffDays, null, locale, dispatcher, user, timeZone);
    }

    /**
     * Snapshot chart that shows the breakdown of leads according to their last activity, in Old / Recent / No activity categories.
     * @param cutoffDays Number of days that cuts off from today date and make it reading point for old and recent activties.
     * @param allowedLeadPartyIds if not null, will only account those leads in the chart
     * @param locale a <code>Locale</code> value
     * @param dispatcher a <code>LocalDispatcher</code> value
     * @param user a <code>GenericValue</code> value
     * @param timeZone a <code>TimeZone</code> value
     * @return file name of the chart PNG
     * @exception Exception if an error occurs
     */
    public static String createActivitiesByLeadSnapshotChart(int cutoffDays, Set<String> allowedLeadPartyIds, Locale locale, LocalDispatcher dispatcher, GenericValue user, TimeZone timeZone) throws Exception {
        Map<String, Object> uiLabelMap = UtilMessage.getUiLabels(locale);
        DomainsLoader domainLoader = new DomainsLoader(new Infrastructure(dispatcher), new User(user));
        PartyRepositoryInterface rep = domainLoader.getDomainsDirectory().getPartyDomain().getPartyRepository();
        final DefaultPieDataset dataset = new DefaultPieDataset();

        // Get date dimension ID according to the cutoff
        Long readingDateDimId = lookupDateDimIdForCutoff(cutoffDays, timeZone, locale, rep.getInfrastructure());

        // Get the ActivityFacts grouped by Lead
        Map<String, List<ActivityFact>> facts = findLeadsActivitiesGroupedBy(ActivityFact.Fields.targetPartyId, allowedLeadPartyIds, rep);

        // Get totals of old, recent and no activity leads
        Set<String> oldPartyIds = new TreeSet<String>();
        Set<String> recentPartyIds = new TreeSet<String>();
        Set<String> noActivityPartyIds = new TreeSet<String>();
        // get all leads
        noActivityPartyIds.addAll(findAllLeadIds(allowedLeadPartyIds, rep));

        // activities are sorted by dateDimId desc, so we can break early
        for (String targetPartyId : facts.keySet()) {
           List<ActivityFact> activities = facts.get(targetPartyId);

           for (ActivityFact fact : activities) {
               noActivityPartyIds.remove(targetPartyId);
               if (fact.getDateDimId() < readingDateDimId) {
                   oldPartyIds.add(targetPartyId);
               } else {
                   recentPartyIds.add(targetPartyId);
               }
               break;
           }
        }

        // make sure there is no double accounting of recent leads in old
        oldPartyIds.removeAll(recentPartyIds);

        // set up the chart
        dataset.setValue((String) uiLabelMap.get("ActivitiesOlder"), oldPartyIds.size());
        dataset.setValue((String) uiLabelMap.get("ActivitiesRecent"), recentPartyIds.size());
        dataset.setValue((String) uiLabelMap.get("ActivitiesNoActivity"), noActivityPartyIds.size());

        return chartDataSet(dataset, (String) uiLabelMap.get("ActivitiesLeadBreakdown"), rep.getInfrastructure());
    }

    private static String chartDataSet(DefaultPieDataset dataset, String title, Infrastructure infrastructure) throws InfrastructureException, IOException {
        Debug.logInfo("Charting dashboard [" + title + "]", MODULE);
        // set up the chart
        JFreeChart chart = ChartFactory.createPieChart(
                title,
                dataset,
                true,                       // include legend
                true,                       // tooltips
                false                       // urls
        );
        chart.setBackgroundPaint(Color.white);
        chart.setBorderVisible(true);
        chart.setPadding(new RectangleInsets(5.0, 5.0, 5.0, 5.0));

        // get a reference to the plot for further customization...
        final PiePlot plot = (PiePlot) chart.getPlot();
        plot.setBackgroundPaint(Color.white);
        plot.setCircular(true);
        plot.setLabelGenerator(new StandardPieSectionLabelGenerator(
            "{0}: {1} / {2}", NumberFormat.getNumberInstance(), NumberFormat.getPercentInstance()
        ));
        plot.setNoDataMessage("No data available");

        Color[] colors = {Color.decode("#" + infrastructure.getConfigurationValue(OpentapsConfigurationTypeConstants.ACTIVITIES_DASHBOARD_LEADS_NEW_COLOR)),
                          Color.decode("#" + infrastructure.getConfigurationValue(OpentapsConfigurationTypeConstants.ACTIVITIES_DASHBOARD_LEADS_OLD_COLOR)),
                          Color.decode("#" + infrastructure.getConfigurationValue(OpentapsConfigurationTypeConstants.ACTIVITIES_DASHBOARD_LEADS_NO_ACTIVITY_COLOR))};
        for (int i = 0; i < dataset.getItemCount(); i++) {
            Comparable<?> key = dataset.getKey(i);
            plot.setSectionPaint(key, colors[i]);
        }

        // save as a png and return the file name
        return ServletUtilities.saveChartAsPNG(chart, CHART_WIDTH, CHART_HEIGHT, null);
    }

    private static Timestamp getTimestampFromCutoffDays(int cutoffDays) {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE, -cutoffDays);
        return new Timestamp(cal.getTime().getTime());
    }

    private static Long lookupDateDimIdForCutoff(int cutoffDays, TimeZone timeZone, Locale locale, Infrastructure infrastructure) throws GenericEntityException {
        return UtilEtl.lookupDateDimensionForTimestamp(getTimestampFromCutoffDays(cutoffDays), infrastructure.getDelegator());
    }

    private static Set<String> findAllLeadIds(Set<String> allowedLeadPartyIds, PartyRepositoryInterface repository) throws RepositoryException {
        EntityCondition condition = EntityCondition.makeCondition(PartyRole.Fields.roleTypeId.name(), RoleTypeConstants.PROSPECT);
        if (allowedLeadPartyIds != null) {
            condition = EntityCondition.makeCondition(condition, EntityCondition.makeCondition(PartyRole.Fields.partyId.name(), EntityOperator.IN, allowedLeadPartyIds));
        }

        return Entity.getDistinctFieldValues(String.class, repository.findList(PartyRole.class, condition, Arrays.asList(PartyRole.Fields.partyId.name()), Arrays.asList(PartyRole.Fields.partyId.asc())), PartyRole.Fields.partyId);
    }

    private static Map<String, List<ActivityFact>> findLeadsActivitiesGroupedBy(ActivityFact.Fields groupedByField, Set<String> allowedLeadPartyIds, PartyRepositoryInterface repository) throws RepositoryException {
        // Get the ActivityFact records grouped by team member or by lead
        EntityCondition condition = EntityCondition.makeCondition(ActivityFact.Fields.targetPartyRoleTypeId.name(), RoleTypeConstants.LEAD);
        if (allowedLeadPartyIds != null) {
            condition = EntityCondition.makeCondition(condition, EntityCondition.makeCondition(PartyRole.Fields.partyId.name(), EntityOperator.IN, allowedLeadPartyIds));
        }
        // order by dateDimId desc, so we can skip older activities when doing the breakdown
        List<ActivityFact> prospectActivityFacts = repository.findList(ActivityFact.class, condition, Arrays.asList(ActivityFact.Fields.targetPartyId.name(), ActivityFact.Fields.dateDimId.name()), Arrays.asList(ActivityFact.Fields.targetPartyId.asc(), ActivityFact.Fields.dateDimId.desc()));
        Debug.logInfo("findLeadsActivitiesGroupedBy, found ActivityFact [" + prospectActivityFacts + "]", MODULE);
        return Entity.groupByFieldValues(String.class, prospectActivityFacts, groupedByField);
    }
}
