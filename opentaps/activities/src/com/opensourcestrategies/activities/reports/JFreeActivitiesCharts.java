/*
 * Copyright (c) 2010 - 2011 Open Source Strategies, Inc.
 *
 * Opentaps is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Opentaps is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Opentaps.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.opensourcestrategies.activities.reports;

import java.awt.Color;
import java.awt.GradientPaint;
import java.io.IOException;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.axis.CategoryAxis;
import org.jfree.chart.axis.CategoryLabelPositions;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.chart.servlet.ServletUtilities;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.ui.RectangleInsets;
import org.ofbiz.base.util.Debug;
import org.ofbiz.entity.GenericEntityException;
import org.ofbiz.entity.GenericValue;
import org.ofbiz.entity.condition.EntityCondition;
import org.ofbiz.entity.condition.EntityOperator;
import org.ofbiz.service.LocalDispatcher;
import org.opentaps.base.constants.OpentapsConfigurationTypeConstants;
import org.opentaps.base.constants.RoleTypeConstants;
import org.opentaps.base.entities.ActivityFact;
import org.opentaps.base.entities.DateDim;
import org.opentaps.base.entities.Party;
import org.opentaps.common.reporting.etl.UtilEtl;
import org.opentaps.common.util.UtilMessage;
import org.opentaps.domain.DomainsLoader;
import org.opentaps.domain.party.PartyRepositoryInterface;
import org.opentaps.foundation.entity.Entity;
import org.opentaps.foundation.infrastructure.Infrastructure;
import org.opentaps.foundation.infrastructure.InfrastructureException;
import org.opentaps.foundation.infrastructure.User;
import org.opentaps.foundation.repository.RepositoryException;
import org.opentaps.foundation.service.Service;

/**
 * Charts for Financials generated by the JFree API.
 */
public class JFreeActivitiesCharts extends Service {

    private static String MODULE = JFreeActivitiesCharts.class.getName();

    /** Width of the generated charts. */
    public static final int CHART_WIDTH = 400;
    /** Height of the generated charts. */
    public static final int CHART_HEIGHT = 300;

    /**
     * Snapshot chart that shows party leads old and recent activities.
     * @param cutoffDays Number of days that cuts off from today date and make it reading point for old and recent activties.
     * @param locale a <code>Locale</code> value
     * @param dispatcher a <code>LocalDispatcher</code> value
     * @param user a <code>GenericValue</code> value
     * @param timeZone a <code>TimeZone</code> value
     * @return file name of the chart PNG
     * @exception Exception if an error occurs
     */
    public static String createActivitiesByLeadSnapshotChart(int cutoffDays, Locale locale, LocalDispatcher dispatcher, GenericValue user, TimeZone timeZone) throws Exception {
        Map<String, Object> uiLabelMap = UtilMessage.getUiLabels(locale);
        DomainsLoader domainLoader = new DomainsLoader(new Infrastructure(dispatcher), new User(user));
        PartyRepositoryInterface rep = domainLoader.getDomainsDirectory().getPartyDomain().getPartyRepository();
        final DefaultCategoryDataset dataset = new DefaultCategoryDataset();

        // Get date dimension ID according to the cutoff
        Long readingDateDimId = lookupDateDimIdForCutoff(cutoffDays, timeZone, locale, rep.getInfrastructure());

        // Get the ActivityFacts grouped by Lead
        Map<String, List<ActivityFact>> leads = findLeadsActivitiesGroupedBy(ActivityFact.Fields.targetPartyId, rep);

        // Add grouped data to chart.

        for (String targetPartyId : leads.keySet()) {
           List<ActivityFact> activities = leads.get(targetPartyId);

           Long oldActivityCount = new Long(0);
           Long newActivityCount = new Long(0);
           ActivityFact lastActivity = null;
           for (ActivityFact fact : activities) {
               if (fact.getDateDimId() < readingDateDimId) {
                   oldActivityCount += countActivity(fact);
               } else {
                   newActivityCount += countActivity(fact);
               }
               lastActivity = fact;
           }

           Party targetParty = lastActivity.getTargetParty();
           String targetPartyLabel = targetParty.getPerson().getFirstName() + " " + targetParty.getPerson().getLastName();
           if (targetParty.getPartySupplementalData() != null) {
               targetPartyLabel = targetParty.getPartySupplementalData().getCompanyName() + "(" + targetPartyLabel + ")";
           }

           Debug.logInfo("Activity by lead [" + targetPartyId + "]: old = " + oldActivityCount + ", new = " + newActivityCount, MODULE);

           dataset.addValue(newActivityCount, (String) uiLabelMap.get("LeadManagementRecentActivities"), targetPartyLabel);
           dataset.addValue(oldActivityCount, (String) uiLabelMap.get("LeadManagementOldActivities"), targetPartyLabel);
        }

        // set up the chart
        return chartDataSet(dataset, (String) uiLabelMap.get("LeadManagementActivityByLead"), (String) uiLabelMap.get("LeadManagementOfActivities"), (String) uiLabelMap.get("CrmLead"), rep.getInfrastructure());
    }

    /**
     * Snapshot chart that shows sales representatives old and recent activities.
     * @param cutoffDays Number of days that cuts off from today date and make it reading point for old and recent activties.
     * @param locale a <code>Locale</code> value
     * @param dispatcher a <code>LocalDispatcher</code> value
     * @param user a <code>GenericValue</code> value
     * @param timeZone a <code>TimeZone</code> value
     * @return file name of the chart PNG
     * @exception Exception if an error occurs
     */
    public static String createActivitiesBySalesRepSnapshotChart(int cutoffDays, Locale locale, LocalDispatcher dispatcher, GenericValue user, TimeZone timeZone) throws Exception {
        Map<String, Object> uiLabelMap = UtilMessage.getUiLabels(locale);
        DomainsLoader domainLoader = new DomainsLoader(new Infrastructure(dispatcher), new User(user));
        PartyRepositoryInterface rep = domainLoader.getDomainsDirectory().getPartyDomain().getPartyRepository();
        final DefaultCategoryDataset dataset = new DefaultCategoryDataset();

        // Get date dimension ID according to the cutoff
        Long readingDateDimId = lookupDateDimIdForCutoff(cutoffDays, timeZone, locale, rep.getInfrastructure());

        // Get the ActivityFacts grouped by Sales Rep
        Map<String, List<ActivityFact>> leads = findLeadsActivitiesGroupedBy(ActivityFact.Fields.teamMemberPartyId, rep);

        // Add grouped data to chart.

        for (String teamMemberPartyId : leads.keySet()) {
           List<ActivityFact> activities = leads.get(teamMemberPartyId);

           Long oldActivityCount = new Long(0);
           Long newActivityCount = new Long(0);
           ActivityFact lastActivity = null;
           for (ActivityFact fact : activities) {
               if (fact.getDateDimId() < readingDateDimId) {
                   oldActivityCount += countActivity(fact);
               } else {
                   newActivityCount += countActivity(fact);
               }
               lastActivity = fact;
           }

           Party targetParty = lastActivity.getTeamParty();
           String targetPartyLabel = targetParty.getPerson().getFirstName() + " " + targetParty.getPerson().getLastName();

           Debug.logInfo("Activity by sales rep [" + teamMemberPartyId + "] : old = " + oldActivityCount + ", new = " + newActivityCount, MODULE);

           dataset.addValue(newActivityCount, (String) uiLabelMap.get("LeadManagementRecentActivities"), targetPartyLabel);
           dataset.addValue(oldActivityCount, (String) uiLabelMap.get("LeadManagementOldActivities"), targetPartyLabel);
        }

        // set up the chart
        return chartDataSet(dataset, (String) uiLabelMap.get("LeadManagementActivityBySalesRep"), (String) uiLabelMap.get("LeadManagementOfActivities"), (String) uiLabelMap.get("LeadManagementSalesRep"), rep.getInfrastructure());
    }

    private static long countActivity(ActivityFact fact) {
        return fact.getPhoneCallActivityCount()
            + fact.getEmailActivityCount()
            + fact.getVisitActivityCount()
            + fact.getOtherActivityCount();
    }

    private static String chartDataSet(DefaultCategoryDataset dataset, String title, String xLabel, String yLabel, Infrastructure infrastructure) throws InfrastructureException, IOException {
        Debug.logInfo("Charting dashboard [" + title + "]", MODULE);
        // set up the chart
        JFreeChart chart = ChartFactory.createBarChart(
                title,
                yLabel,
                xLabel,
                dataset,
                PlotOrientation.HORIZONTAL,
                true,                       // include legend
                true,                       // tooltips
                false                       // urls
        );
        chart.setBackgroundPaint(Color.white);
        chart.setBorderVisible(true);
        chart.setPadding(new RectangleInsets(5.0, 5.0, 5.0, 5.0));

        // get a reference to the plot for further customisation...
        final CategoryPlot plot = chart.getCategoryPlot();
        plot.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT);

        // get the bar renderer to put effects on the bars
        final BarRenderer renderer = (BarRenderer) plot.getRenderer();
        renderer.setDrawBarOutline(false); // disable bar outlines

        // set up gradient paint on bar
        final GradientPaint recentGp = new GradientPaint(
            0.0f, 0.0f, Color.decode("#" + infrastructure.getConfigurationValue(OpentapsConfigurationTypeConstants.ACTIVITIES_DASHBOARD_LEADS_NEW_COLOR)),
            0.0f, 0.0f, Color.GRAY
        );
        renderer.setSeriesPaint(0, recentGp);

        final GradientPaint oldGp = new GradientPaint(
            0.0f, 0.0f, Color.decode("#" + infrastructure.getConfigurationValue(OpentapsConfigurationTypeConstants.ACTIVITIES_DASHBOARD_LEADS_OLD_COLOR)),
            0.0f, 0.0f, Color.GRAY
        );
        renderer.setSeriesPaint(1, oldGp);

        // change the auto tick unit selection to integer units only...
        final NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();
        rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());

        // tilt the category labels so they fit
        CategoryAxis domainAxis = plot.getDomainAxis();
        domainAxis.setCategoryLabelPositions(CategoryLabelPositions.createUpRotationLabelPositions(Math.PI / 6.0));

        // save as a png and return the file name
        return ServletUtilities.saveChartAsPNG(chart, CHART_WIDTH, CHART_HEIGHT, null);
    }

    private static Timestamp getTimestampFromCutoffDays(int cutoffDays) {
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE, -cutoffDays);
        return new Timestamp(cal.getTime().getTime());
    }

    private static Long lookupDateDimIdForCutoff(int cutoffDays, TimeZone timeZone, Locale locale, Infrastructure infrastructure) throws GenericEntityException {
        return lookupDateDimIdForTimestamp(getTimestampFromCutoffDays(cutoffDays), timeZone, locale, infrastructure);
    }

    private static Long lookupDateDimIdForTimestamp(Timestamp timestamp, TimeZone timeZone, Locale locale, Infrastructure infrastructure) throws GenericEntityException {

        DateFormat dayOfMonthFmt = new SimpleDateFormat("dd");
        DateFormat monthOfYearFmt = new SimpleDateFormat("MM");
        DateFormat yearNumberFmt = new SimpleDateFormat("yyyy");
        String dayOfMonth = dayOfMonthFmt.format(timestamp);
        String monthOfYear = monthOfYearFmt.format(timestamp);
        String yearNumber = yearNumberFmt.format(timestamp);

        EntityCondition dateDimConditions = EntityCondition.makeCondition(EntityOperator.AND,
                                                 EntityCondition.makeCondition(DateDim.Fields.dayOfMonth.name(), dayOfMonth),
                                                 EntityCondition.makeCondition(DateDim.Fields.monthOfYear.name(), monthOfYear),
                                                 EntityCondition.makeCondition(DateDim.Fields.yearNumber.name(), yearNumber));

        Long dateDim = UtilEtl.lookupDimension(DateDim.class.getSimpleName(), DateDim.Fields.dateDimId.getName(), dateDimConditions, infrastructure.getDelegator());
        if (dateDim == 0L) {
            Debug.logWarning("Could not find a DateDim for date " + yearNumber + "-" + monthOfYear + "-" + dayOfMonth, MODULE);
        }
        return dateDim;
    }

    private static Map<String, List<ActivityFact>> findLeadsActivitiesGroupedBy(ActivityFact.Fields groupedByField, PartyRepositoryInterface repository) throws RepositoryException {
        // Get the ActivityFact records grouped by team member or by lead
        List<ActivityFact> prospectActivityFacts = repository.findList(ActivityFact.class, EntityCondition.makeCondition(ActivityFact.Fields.targetPartyRoleTypeId.name(), RoleTypeConstants.LEAD));
        Debug.logInfo("findLeadsActivitiesGroupedBy, found ActivityFact [" + prospectActivityFacts + "]", MODULE);
        return Entity.groupByFieldValues(String.class, prospectActivityFacts, groupedByField);
    }
}
